\name{unique.matrix}
\alias{unique.matrix}
\alias{duplicated.matrix}
\alias{anyDuplicated.matrix}

\title{Finding Unique or Duplicated Rows or Columns for Atomic Matrices}
\description{
These S3 methods are alternative (typically much faster) implementations of couterparts in the \code{base} pacakge for atomic matrices.  

  \code{unique.matrix} returns a matrix with duplicated rows (or columns) removed. 
  
  \code{duplicated.matrix} returns a logical vector indicating which rows (or columns) are duplicated. 

  \code{anyDuplicated.matrix} is an efficient shortcut for \code{any(duplicated.matrix)}.
}

\usage{
\method{unique}{matrix}(x, incomparables = FALSE, MARGIN = 1,
       fromLast = FALSE, \dots)
\method{duplicated}{matrix}(x, incomparables = FALSE, MARGIN = 1,
           fromLast = FALSE, \dots)
\method{anyDuplicated}{matrix}(x, incomparables = FALSE,
           MARGIN = 1, fromLast = FALSE, \dots)
}


\arguments{
  \item{x}{an atomic matrix of mode \code{"numeric"}, \code{"integer"}, \code{"logical"}, \code{"complex"}, \code{"character"} or \code{"raw"}. When \code{x} is not atomic or when it is not a matrix, the \code{\link[base:unique]{base::unique.matrix}} in the \code{base} package will be called. }
  
  \item{incomparables}{a vector of values that cannot be compared, as in \code{\link[base:unique]{base::unique.matrix}}. Only when \code{incomparables=FALSE} will the code in \code{uniqueAtomMat} package be used; otherwise, the \code{base} version will be called. }
  
  \item{fromLast}{logical indicating if duplication should be considered
    from the last, as in \code{\link[base:unique]{base::unique.matrix}}. }
    
  \item{\dots}{arguments for particular methods.}
  
  \item{MARGIN}{a numeric scalar, the matrix margin to be held fixed, as in \code{\link{apply}}. Only when \code{length(MARGIN)=1} and \code{MARGIN=1} or \code{2} will the code in \code{uniqueAtomMat} package be used; otherwise, the \code{base} version will be called.}
}

\details{
These S3 methods are alternative implementations of couterparts in the \code{base} pacakge for atomic matrices (i.e., double, integer, logical, character, complex and raw) directly based on C++ Standard Template Library (STL) \code{std::set}. The implementation treats the whole row (or columns) \emph{vector} as the key, without converting the mode to \code{character} and collapsing them into a \emph{scalar} as done in \code{base}. Depending on the C++ compiler used on the system, STL \code{std::set} is typically implemented as a sel-balancing tree (usually a red-black tree), which takes \eqn{latex}{O[n\log{(n)}]} to find all duplicates, where \code{n=dim(x)[MARGIN]}.

  Missing values are regarded as equal, but \code{NaN} is not equal to
  \code{NA_real_}. 
  
  Further, in contrast to the \code{base} counter-parts, characters and numeric values are compared directly based on their internal representations; i.e., no encoding issues for characters nor rounding issues for floating-points are considered. Complex values are compared by their real and imaginary parts separately. All comparisons are exact. 


  For the default methods, and whenever there are equivalent method
  definitions for \code{duplicated} and \code{anyDuplicated},
  \code{anyDuplicated(x, ...)} is a \dQuote{generalized} shortcut for
  \code{any(duplicated(x, ...))}, in the sense that it returns the
  \emph{index} \code{i} of the first duplicated entry \code{x[i]} if
  there is one, and \code{0} otherwise.  Their behaviours may be
  different when at least one of \code{duplicated} and
  \code{anyDuplicated} has a relevant method.

}

\value{
  \code{unique.matrix} returns a matrix with duplicated rows (if \code{MARGIN=1}) or columns (if \code{MARGIN=2}) removed. 
  
  \code{duplicated.matrix} returns a logical vector indicating which rows (if \code{MARGIN=1}) or columns (if \code{MARGIN=2}) are duplicated. 

  \code{anyDuplicated.matrix} returns an integer indicating the index of the first duplicate if any, and \code{0L} otherwise.

}
\section{Warning}{
In contrast to the \code{base} counter-parts, characters and numeric values are compared directly based on their internal representations; i.e., no encoding issues for characters nor rounding issues for floating-points are considered.  Complex values are compared by their real and imaginary parts separately. All comparisons are exact.   \link{Long vectors} are not supported yet. 
}


\seealso{
  \code{\link[base:duplicated]{base::duplicated}}, \code{\link[base:unique]{base::unique}}
}

\examples{
## prepare test data: 
set.seed(9992722L, kind="Mersenne-Twister")
x.double=model.matrix(~gl(5,8))[sample(40), ]
x.integer=as.integer(x.double); attributes(x.integer)=attributes(x.double)
x.logical=as.logical(x.double); attributes(x.logical)=attributes(x.double)
x.character=as.character(x.double); attributes(x.character)=attributes(x.double)
x.complex=as.complex(x.double); attributes(x.complex)=attributes(x.double)
x.raw=as.raw(x.double); attributes(x.raw)=attributes(x.double)

## compare results with base:
stopifnot(identical(base::duplicated.matrix(x.double), 
                    uniqueAtomMat::duplicated.matrix(x.double)
))
stopifnot(identical(base::duplicated.matrix(x.integer, fromLast=TRUE), 
                    uniqueAtomMat::duplicated.matrix(x.integer, fromLast=TRUE)
))
stopifnot(identical(base::duplicated.matrix(t(x.logical), MARGIN=2L), 
                    uniqueAtomMat::duplicated.matrix(t(x.logical), MARGIN=2L) 
))
stopifnot(identical(base::duplicated.matrix(t(x.character), MARGIN=2L, fromLast=TRUE), 
                    uniqueAtomMat::duplicated.matrix(t(x.character), MARGIN=2L, fromLast=TRUE) 
))

stopifnot(identical(base::unique.matrix(x.complex), 
                    uniqueAtomMat::unique.matrix(x.complex) 
))
stopifnot(identical(base::unique.matrix(x.raw), 
                    uniqueAtomMat::unique.matrix(x.raw) 
))


## benchmarking
if (require(microbenchmark)){
    print(microbenchmark(base::duplicated.matrix(x.double)))
    print(microbenchmark(uniqueAtomMat::duplicated.matrix(x.double)))

    print(microbenchmark(base::duplicated.matrix(x.character)))
    print(microbenchmark(uniqueAtomMat::duplicated.matrix(x.character)))
}else{
    print(system.time(replicate(5e3L, base::duplicated.matrix(x.double))))
    print(system.time(replicate(5e3L, uniqueAtomMat::duplicated.matrix(x.double))))

    print(system.time(replicate(5e3L, base::duplicated.matrix(x.character))))
    print(system.time(replicate(5e3L, uniqueAtomMat::duplicated.matrix(x.character))))
}


\dontshow{ 
# further testing
xna.double=x.double; 
xna.double[1,2]=xna.double[2,3]=xna.double[3,3]=NA_real_
xna.double[4,1]=NaN
xna.integer=as.integer(xna.double); attributes(xna.integer)=attributes(xna.double)
xna.logical=as.logical(xna.double); attributes(xna.logical)=attributes(xna.double)
xna.character=as.character(xna.double); attributes(xna.character)=attributes(xna.double)
xna.complex=as.complex(xna.double); attributes(xna.complex)=attributes(xna.double)
xna.raw=suppressWarnings(as.raw(xna.double)); attributes(xna.raw)=attributes(xna.double)

x.objs = as.vector(outer(c('x','xna'), c('double','integer','logical','character','complex','raw'),paste,sep='.'))
test.cases=expand.grid(x = x.objs, MARGIN=1:2, fromLast=c(FALSE, TRUE), stringsAsFactors=FALSE)

for(i in seq_len(nrow(test.cases))){
    this.case=as.list(test.cases[i,])
    this.case$x=get(this.case$x)
    stopifnot(
        identical(do.call(base::unique.matrix, this.case), 
                  do.call(uniqueAtomMat::unique.matrix, this.case)),
        identical(do.call(base::duplicated.matrix, this.case), 
                  do.call(uniqueAtomMat::duplicated.matrix, this.case))
    )
}

}

\dontrun{
anyDuplicated(x)
anyDuplicated(x, fromLast = TRUE)
}

}
\keyword{manip}
\keyword{logic}
